/**
 * Namespace for components that are shared across views.
 */
const IDEALS = {

    /**
     * Application-wide fade time, for consistency.
     */
    FADE_TIME: 200,

    /**
     * High-level client for interacting with IDEALS.
     *
     * @constructor
     */
    Client: function() {

        const ROOT_URL   = $("input[name=root_url]").val();
        const CSRF_TOKEN = $("input[name=authenticity_token]").val();

        /**
         * Sends an HTTP DELETE request to the given URI.
         *
         * @param uri {String}
         * @param onSuccess {Function}
         * @param onError {Function}
         */
        this.delete = function (uri, onSuccess, onError) {
            $.ajax({
                type: "DELETE",
                url: uri,
                headers: { "X-CSRF-Token": CSRF_TOKEN },
                success: onSuccess,
                error: onError
            });
        };

        /**
         * @param unitID {Number}
         * @param onSuccess {Function} Function accepting response data.
         */
        this.fetchUnitCollections = function(unitID, onSuccess) {
            $.ajax({
                method: "GET",
                url: ROOT_URL + "/units/" + unitID + "/collections?for-select=true",
                headers: { "X-CSRF-Token": CSRF_TOKEN },
                success: onSuccess
            });
        };

        /**
         * @param query {String}
         * @param onSuccess {Function} Function accepting response data.
         * @return
         */
        this.fetchUsers = function(query, onSuccess) {
            const MAX_RESULTS = 8;
            $.ajax({
                url: ROOT_URL + "/users.json?window=" + MAX_RESULTS + "&q=" + query,
                method: "get",
                success: function(data, status, xhr) {
                    if (onSuccess) {
                        onSuccess(data, status, xhr);
                    }
                }
            });
        };

        /**
         * Sends a file to the server, creating a new Bitstream attached to an
         * Item.
         *
         * @param file [File]                  File to upload.
         * @param uri [String]                 URI to POST the file to.
         * @param onProgressChanged {Function} Function accepting an event
         *                                     argument.
         * @param onSuccess {Function}         Function accepting a string
         *                                     argument. The string is the URI
         *                                     of the created bitstream.
         */
        this.uploadFile = function(file, uri, onProgressChanged, onSuccess) {
            const xhr = new XMLHttpRequest();
            if (onProgressChanged) {
                xhr.upload.addEventListener("progress", onProgressChanged);
            }
            xhr.open("POST", uri, true);
            xhr.setRequestHeader("X-Filename", file.name);
            xhr.setRequestHeader("X-Content-Length", file.size);
            xhr.setRequestHeader("X-CSRF-Token", CSRF_TOKEN);
            xhr.send(file);

            xhr.onreadystatechange = function () {
                if (this.readyState === this.HEADERS_RECEIVED) {
                    if (onSuccess) {
                        onSuccess(xhr.getResponseHeader("Location"));
                    }
                }
            };
        };
    },

    /**
     * Enables the an expandable list of units generated by
     * {UnitsHelper#unit_list}.
     *
     * @constructor
     */
    ExpandableResourceList: function() {
        const ROOT_URL = $("input[name=root_url]").val();

        const setToggleState = function(elem, expanded) {
            const icon = expanded ? "fa-minus-square" : "fa-plus-square";
            elem.html("<i class=\"far " + icon + "\"></i>");
        };

        const insert = function(data, container) {
            if (data.length < 1) {
                return;
            }
            var html = "<ul>";
            $.each(data, function(index, obj) {
                html += "<li data-id=\"" + obj.id + "\">";
                if (obj.numCollections > 0 || obj.numChildren > 0) {
                    html += "<button class=\"btn btn-link expand\" type=\"button\" data-class=\"" + obj.class + "\">";
                    html +=   "<i class=\"far fa-plus-square\"></i>";
                    html += "</button>";
                }
                html +=   "<a href=\"" + obj.uri + "\">";
                html +=     (obj.class === "Unit") ?
                    "<i class=\"fa fa-university\"></i> " :
                    "<i class=\"far fa-folder-open\"></i> ";
                html +=     obj.title;
                html +=   "</a>";
                html += "</li>";
            });
            html += "</ul>";
            container.append(html);
            attachExpandButtonListeners();
        };

        const attachExpandButtonListeners = function() {
            $("button.expand").off("click").on("click", function () {
                const button = $(this);
                if (button.hasClass("expanded")) {
                    button.siblings("ul").remove();
                    setToggleState(button, false);
                    button.removeClass("expanded");
                } else {
                    button.addClass("expanded");
                    const id = button.parents("li").data("id");
                    setToggleState(button, true);
                    // Query for sub-units and sub-collections.
                    $.ajax({
                        method: "GET",
                        url: (button.data("class") === "Unit") ?
                            ROOT_URL + "/units/" + id + "/children" :
                            ROOT_URL + "/collections/" + id + "/children",
                        success: function (data, status, xhr) {
                            insert(data, button.parent());
                        }
                    });
                    if (button.data("class") === "Unit") {
                        // Query for collections that are immediate children of units.
                        $.ajax({
                            method: "GET",
                            url: ROOT_URL + "/units/" + id + "/collections",
                            success: function (data, status, xhr) {
                                insert(data, button.parent());
                            }
                        });
                    }
                }
            });
        };
        attachExpandButtonListeners();
    },

    FacetSet: function() {
        /**
         * Enables the facets returned by one of the facets_as_x() helpers.
         */
        this.init = function() {
            $("[name='fq[]']").off().on("change", function () {
                if ($(this).prop("checked")) {
                    window.location = $(this).data("checked-href");
                } else {
                    window.location = $(this).data("unchecked-href");
                }
            });
        }
    },

    MetadataEditor: function() {
        $("button.add").on("click", function(e) {
            const last_tr = $(this).parent(".form-group").find("table.metadata > tbody > tr:last-child");
            const clone = last_tr.clone();
            clone.find("input").val("");
            last_tr.after(clone);
            updateEventListeners();
            e.preventDefault();
        });
        updateEventListeners();

        function updateEventListeners() {
            $("button.remove").off("click").on("click", function () {
                if ($(this).parents("table").find("tr").length > 1) {
                    $(this).parents("tr").remove();
                }
            });
        }
    },

    /**
     * Supports "multi-element lists" (for want of a better term) in forms.
     * These are lists that support a model's one-to-many property where there
     * is one element per property, a remove button next to each element, and
     * an add button after the last element.
     *
     * @constructor
     */
    MultiElementList: function(minElements = 1) {
        $("button.add").on("click", function(e) {
            const clone = $(this).prev().clone();
            clone.find("input").val("");
            clone.find("select").attr("disabled", false);
            clone.removeClass("d-none");
            $(this).before(clone);
            updateEventListeners();
            if (clone.hasClass("user")) {
                new IDEALS.UserAutocompleter(clone.find("input"));
            }
            e.preventDefault();
        });
        updateEventListeners();

        function updateEventListeners() {
            $("button.remove").off("click").on("click", function () {
                const numIGs = $(this).parents(".form-group").find(".input-group").length;
                if (numIGs > minElements) {
                    const parentIG = $(this).parents(".input-group");
                    // Don't remove the last one, as the add button needs to
                    // clone it.
                    if (numIGs > 1) {
                        parentIG.remove();
                    } else {
                        parentIG.addClass("d-none");
                        parentIG.find("select").attr("disabled", true);
                    }
                }
            });
        }
    },

    NonNetIDLoginForm: function() {
        const ROOT_URL = $("input[name=root_url]").val();
        const modal    = $("#non-netid-login-modal");
        const flash    = modal.find(".alert");
        modal.find("button[type=submit]").on("click", function(event) {
            event.preventDefault();
            $.ajax({
                method: "POST",
                url: ROOT_URL + "/auth/identity/callback",

                data: $(this).parents("form").serialize(),
                success: function() {
                    flash.text("Login succeeded. One moment...")
                        .removeClass("alert-danger")
                        .addClass("alert-success")
                        .show();
                    modal.on("hidden.bs.modal", function () {
                        location.reload();
                    });
                    setTimeout(function() {
                        modal.modal("hide");
                    }, 2000);
                },
                error: function(data, status, xhr) {
                    console.log(data);
                    console.log(status);
                    console.log(xhr);
                    flash.removeClass("alert-success")
                        .addClass("alert-danger")
                        .text("Login failed.")
                        .show();
                }
            });
        });
    },

    /**
     * @param textField {jQuery} Text field element.
     * @constructor
     */
    UserAutocompleter: function(textField) {
        textField.on("keyup", function() {
            const textField = $(this);
            const menu      = textField.parent().find(".dropdown-menu");
            const query     = textField.val();
            if (query.length < 1) {
                menu.hide();
                return;
            }
            menu.css("top", $(this).position().top + $(this).height() + 14 + "px");
            menu.css("left", "14px");

            new IDEALS.Client().fetchUsers(query, function(data) {
                if (data['numResults'] > 0) {
                    menu.empty();
                    data['results'].forEach(function(result) {
                        const menuItem = $("<div class=\"dropdown-item\"></div>");
                        // It's important that all menu items be unique
                        // across all users. For users that have a name, we
                        // append their email. For unnamed users, we include
                        // only their email.
                        if (result['name'].length > 0) {
                            menuItem.html(result['name'] +
                                " <small>(" + result['email'] + ")</small>");
                        } else {
                            menuItem.html(result['email']);
                        }
                        menu.append(menuItem);
                        menuItem.on("click", function() {
                            textField.val($(this).text());
                            menu.hide();
                        });
                    });
                    menu.show();
                } else {
                    menu.hide();
                }
            });
        });
    },

    Util: {

        /**
         * Converts a byte size integer (like 50000) into a string like
         * "50 KB." The output harmonizes with that of Rails'
         * `number_to_human_size()` method.
         *
         * @param bytes {Number} Byte size integer.
         */
        formatBytes: function(bytes) {
            const sizes = ["bytes", "KB", "MB", "GB", "TB"];
            if (bytes === 0) {
                return "0 bytes";
            }
            const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            return Math.round(bytes / Math.pow(1024, i), 2) + " " + sizes[i];
        }

    }
};

const ideals_ready = function () {

    new IDEALS.NonNetIDLoginForm();

    var showChar = 140;
    var ellipsestext = "...";
    var moretext = "more";
    var lesstext = "less";
    $('.more').each(function () {
        var content = $(this).html();

        if (content.length > showChar) {

            var c = content.substr(0, showChar);
            var h = content.substr(showChar, content.length - showChar);

            var html = c + '<span class="moreellipses">' + ellipsestext + '&nbsp;</span><span class="morecontent"><span>' + h + '</span>&nbsp;&nbsp;<a href="" class="morelink">' + moretext + '</a></span>';

            $(this).html(html);
        }

    });

    $(".morelink").click(function () {
        if ($(this).hasClass("less")) {
            $(this).removeClass("less");
            $(this).html(moretext);
        } else {
            $(this).addClass("less");
            $(this).html(lesstext);
        }
        $(this).parent().prev().toggle();
        $(this).prev().toggle();
        return false;
    });

    // Copy the URL "q" argument into the filter field, as the browser won't do
    // this automatically.
    const queryArgs = new URLSearchParams(location.search);
    if (queryArgs.has("q")) {
        $("input[name=q]").val(queryArgs.get("q"));
    }

    // Submit forms when a "sort" select menu changes.
    $("[name=sort]").on("change", function() {
        $(this).parents("form:first").submit();
    });

    // Save the last-selected tab in a cookie.
    $('a[data-toggle="tab"]').on('click', function(e) {
        Cookies.set('last_tab', $(e.target).attr('href'));
    });

    // Activate the cookie-stored tab, if it exists.
    const lastTab = Cookies.get('last_tab');
    if (lastTab) {
        $('a[href="' + lastTab + '"]').click();
    }

    // Don't allow disabled anchors to be clicked.
    $("a[disabled='disabled']").on("click", function() {
        return false;
    });
};
$(document).ready(ideals_ready);